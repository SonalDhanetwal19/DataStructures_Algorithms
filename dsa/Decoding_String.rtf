{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fmodern\fcharset0 Courier;\f2\fnil\fcharset0 HelveticaNeue-Bold;
\f3\fnil\fcharset0 Menlo-Bold;\f4\fnil\fcharset0 Menlo-Regular;\f5\fswiss\fcharset0 Helvetica;
\f6\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;\red29\green38\blue42;\red255\green255\blue255;\red67\green91\blue103;
\red245\green247\blue249;}
{\*\expandedcolortbl;;\cssrgb\c14902\c19608\c21961;\cssrgb\c100000\c100000\c100000;\cssrgb\c32941\c43137\c47843;
\cssrgb\c96863\c97647\c98039;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Given an encoded string, return its decoded string.
\b0 \
The encoding rule is:\'a0
\f1\fs26 \cf4 \cb5 \strokec4 k[encoded_string]
\f0\fs28 \cf2 \cb3 \strokec2 , where the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 encoded_string
\f0\fs28 \cf2 \cb3 \strokec2 \'a0inside the square brackets is being repeated exactly\'a0
\f1\fs26 \cf4 \cb5 \strokec4 k
\f0\fs28 \cf2 \cb3 \strokec2 \'a0times. Note that\'a0
\f1\fs26 \cf4 \cb5 \strokec4 k
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is guaranteed to be a positive integer.\
You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 k
\f0\fs28 \cf2 \cb3 \strokec2 . For example, there will not be input like\'a0
\f1\fs26 \cf4 \cb5 \strokec4 3a
\f0\fs28 \cf2 \cb3 \strokec2 \'a0or\'a0
\f1\fs26 \cf4 \cb5 \strokec4 2[4]
\f0\fs28 \cf2 \cb3 \strokec2 .\
The test cases are generated so that the length of the output will never exceed\'a0
\f1\fs26 \cf4 \cb5 \strokec4 10
\fs19\fsmilli9750 5
\f0\fs28 \cf2 \cb3 \strokec2 .\

\f2\b Example 1:
\f0\b0 \
\pard\pardeftab720\partightenfactor0

\f3\b\fs26 \cf2 \cb5 Input:
\f4\b0  s = "3[a]2[bc]"\

\f3\b Output:
\f4\b0  "aaabcbc"\
\pard\pardeftab720\sa280\partightenfactor0

\f2\b\fs28 \cf2 \cb3 Example 2:
\f0\b0 \
\pard\pardeftab720\partightenfactor0

\f3\b\fs26 \cf2 \cb5 Input:
\f4\b0  s = "3[a2[c]]"\

\f3\b Output:
\f4\b0  "accaccacc"\
\pard\pardeftab720\sa280\partightenfactor0

\f2\b\fs28 \cf2 \cb3 Example 3:
\f0\b0 \
\pard\pardeftab720\partightenfactor0

\f3\b\fs26 \cf2 \cb5 Input:
\f4\b0  s = "2[abc]3[cd]ef"\

\f3\b Output:
\f4\b0  "abcabccdcdcdef"\
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \'a0\

\f2\b Constraints:
\f0\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f1\fs26 \cf4 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 1 <= s.length <= 30
\f0\fs28 \cf2 \cb1 \strokec2 \
\ls1\ilvl0
\f1\fs26 \cf4 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 s
\f0\fs28 \cf2 \cb3 \strokec2 \'a0consists of lowercase English letters, digits, and square brackets\'a0
\f1\fs26 \cf4 \cb5 \strokec4 '[]'
\f0\fs28 \cf2 \cb3 \strokec2 .\cb1 \
\ls1\ilvl0
\f1\fs26 \cf4 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 s
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is guaranteed to be\'a0
\f2\b a valid
\f0\b0 \'a0input.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 All the integers in\'a0
\f1\fs26 \cf4 \cb5 \strokec4 s
\f0\fs28 \cf2 \cb3 \strokec2 \'a0are in the range\'a0
\f1\fs26 \cf4 \cb5 \strokec4 [1, 300]
\f0\fs28 \cf2 \cb3 \strokec2 .\cb1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f5\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\

\f6\b https://www.youtube.com/watch?v=SF2W6VDs7bc
\f5\b0 \
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
class Solution \{\
    public String decodeString(String s) \{\
        Stack<Integer> countStack = new Stack<>();\
        Stack<String> wordStack = new Stack<>();\
        Integer number = 0;\
        StringBuilder word = new StringBuilder();\
        for(int i=0; i < s.length(); i++)\
        \{\
            char c = s.charAt(i);\
            if(Character.isDigit(c))\
            \{\
                number = number * 10 + (c - '0');\
            \}\
            else if(Character.isLetter(c))\
            \{\
                word = word.append(c);\
            \}\
            else if(c == '[')\
               \
            \{\
                countStack.push(number); \
                wordStack.push(word.toString());\
                number = 0;\
                word = new StringBuilder();\
            \}\
            else\
            \{\
                int count = countStack.pop();\
                StringBuilder duplicatedWord = new StringBuilder(wordStack.pop());\
               \
                for(int j=0; j<count ; j++)\
                \{\
                    duplicatedWord.append(word);\
                \}\
                word = duplicatedWord;\
                \
            \}\
            \
            \
        \}\
        return word.toString();\
    \}\
\}\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Time complexity - o(n*m)\
Space complexity o(n+m)}